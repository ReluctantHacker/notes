|#############################################################################################################|
1. 簡史
reference: 電腦簡史 齒輪時代 --泛科學(pansci), 電腦簡史 數位時代 --泛科學(pansci)
以下pansci講了很多課外的東西, 你挑重點, 剩下的有空再看
https://pansci.asia/archives/tag/%E9%9B%BB%E8%85%A6%E7%B0%A1%E5%8F%B2
https://www.youtube.com/watch?v=FANB4Ubbvgc&ab_channel=%E6%B7%B7%E4%B9%B1%E5%8D%9A%E7%89%A9%E9%A6%86ChaosMuseum
	Ā. 其實古代科學家在進行較高精度的計算時候, 多採用"查表"的方式, 例如log或三角函數, 都是事先算出來記錄在表內, 要用到的時候再去查, 但此法終究治標不治本, 計算機的發明還是必要的
	A. 100 BC, Antikythira mechanism, 古希臘人利用多組齒輪來模擬星象變化, 原理和時鐘有點像, 時針分針用不同齒輪
	B. 3000 BC, 算盤(幾千年的東西就不用拿出來講了, 有空再研究即可)
	C. 1642 AC, 法國數學家Blaise Pascal發明了機械式的加法器Pascaline
	D. Lebneiz用了將近20年, 改良Pascal的計算器, 採用"「步進滾筒」 (stepped drum) ，又稱「萊布尼茲輪」 (Leibniz Wheel)", 使機械式計算器能處理相乘相除. 除此之外Lebneiz也研究了一些二進制的研究
	E. 1822 AC, Charles Babbage(巴貝奇) 開始設計 Difference Engine(差分機)，可自動算出對數表和三角函數表並打印出來。Babbage後來因為經費以及其他技術上的問題, 放棄了差分機, 而是轉而投入另一種更先進, 不再只是只能處理單一問題的"可編程計算器"分析機".
	reference:
	https://pansci.asia/archives/186892
		a. 差分(finite difference)---> 其實就是微分的有限版本, 你早就已經會了只是不自知
			I. 微分: df(x)/dx = lim_(dx->0) (f(x)-f(x+dx))/dx, 如果f(x)是簡單的多項式, 解析解很容易得到, 但如果不是的話, 你不能再用dx->0的極限方法, 得假設dx是有限微小值, 即是差分, 他是數值解的概念. 當然實際上差分理論有很多東西, 這裡只提到最基本的概念.

	F. 可編程計算機
		a. Babbage的可編程計算機靈感來自於"織布機(loom)"
		reference of "how basic loom works", 需要梭子, 梳子, 看到影片後基本原理一目了然:
		https://www.youtube.com/watch?v=rwwhx7HX8MA&ab_channel=%E4%BF%A1%E8%AA%BC%E5%9F%BA%E9%87%91%E6%9C%83
		https://www.youtube.com/watch?v=lYGXRYmATks&ab_channel=TextileVlog

		b. 在Babbage研究分析機的100多年前, 一個法國人沃康松(就是發明大便鴨的人)接受政府委託, 為了改良傳統織布機引入了"編程"的概念. 這個編程的概念來源於"滾筒風琴"或是"音樂盒". 最簡單的織布機針對"素面"布料, 只要奇數線和偶數線交替穿插, 節奏交替, 沒什麼複雜的, 但是如果要織布機做出有花紋的圖案, 難度就大幅提升了. 早在沃康松之前就有個人叫布雄已經用了類系的原理嘗試過了, 他很清楚滾筒風琴的圓筒如何製作：先按照樂譜上的音符在紙上畫好記號，接著將紙裹住圓筒表面，然後在記號處──釘上鐵釘，再取下紙張即大功告成。不過布雄並沒有依樣畫葫蘆，打造另一個用於織布機的圓筒。這是他的另一個洞見：打了孔的紙已經包含如何控制音管的資訊，做成圓筒只是沿襲自音樂盒的作法，並非絕對必要。也許織布機無需圓筒，用打孔的紙張就能控制經線起落？他還真的做出來了, 但由於紙張很容易破裂, 所以機器整體而言還是沒什麼屁用. 三年後他的助手改良了缺陷, 用厚紙板串接的方式, 克服了紙張易破以及長度限制. 只是由於操作步驟還是很麻煩, 整體而言沒有織布效率沒有快多少, 因此還是沒屁用. 多年後沃康松才奉政府命令續接此任務. 沃康松以布雄的設計為基礎，但將紙帶改為裹住一個金屬大圓筒. 但由於限制還是很多, 所以還是沒屁用. 多年後雅卡爾統合成功建織布機
		reference:
		https://www.youtube.com/watch?v=K6NgMNvK52A&ab_channel=VictoriaandAlbertMuseum

		c. Babbage承襲設計造分析機, Babbage的突破可以參考以下reference, 較複雜, 但基本上他的突破是以下兩點
		reference:
		https://pansci.asia/archives/187657
			I. 用"不同打洞紙卡(punched card)"做"不同計算的動作", 達到能夠計算任何東西的效果.
			II. 記憶元件與計算元件分離, 使機器運作更加合理

		d. Babbage由於差分機製造失敗, 這次分析機被英國政府打槍, 英國政府不願支助Babbage, 但他不孤獨, 一位奇女子Ada Lovelace理解了分析機的重大意義, 鼎力相助. 而且Ada理解了打孔紙卡的意義, 設計出了具有迴圈的演算法, 用來計算"白努力數", 算是史上第一位程序設計師
		e. Babbage的設計終究不受青睞, 或許市場需求不到位, 但也受限於"齒輪"科技的運算速度有限. 這樣的限制要一直到數位電路時代才能突破.

	G. 同時"類比式計算機"也開始蓬勃發展, 例如面積儀(plainmeter):
	reference:
	https://www.youtube.com/watch?v=XQXO6edF6sA&ab_channel=calculatryx
		a. Maxwell, Thomason, Kelven等等物理巨人都有著手參與改良面積儀的工作
		b. 類比式計算機承襲面積儀, 一直到二戰前都還有再發展, 用來解微分, 積分等等工作, 甚至一度成為唯一能解高階微分方程的機器, 在研究機構成為主流工具.

	H. 1884 AC, 合理樂(Herman Hollerith)利用繼電器和punched card, 設計出第一台用電力驅動的自動製表機, 用於人口普查, 取得了不錯的效果. 他之後與另外一位傢伙成立了赫赫有名的IBM.
		a. 合理樂punched card 原理:
			I. 紙上有很多columns and rows, 有hole來記錄data, 通常有hole表示1, 沒hole表示0
			II. 打hole用punch card machine, 讀卡用card reader

	I. 計算機在何樂禮手中首度接上了電，但電力只是用來驅動繼電器進行計算，靠的是電磁鐵的機械動作，而不是電流本身。因此何樂禮的自動製表機只能算是電力驅動的機械式計算機(與我先前討論的都屬於機械式)，仍然不是電子計算機。計算機要蛻變為現代電腦，必須擺脫機械方式，改用電流本身來做計算。而要做到這一點，首先得放棄大家習以為常的十進位，改用二進位。

	J. 1937AC, 赫赫有名的夏農提出了所有電路都能用二進制布林代數表示, 並列出基本公理與交換律、結合律、……等運算法則。接著他再進一步分析不同型式的複雜電路，證明也都可以用布林代數表示。最後夏農強調這套方法不只可以用於現有的機器，還可以解決各種問題

	K. 數位計算機的先驅者中，最先動手打造的是德國的楚澤 (Konrad Zuse), 1936 年夏天，楚澤把家裡客廳當作工作坊，開始打造 Z1 計算機（原本楚澤取為V1，V 代表德文 “Versuchsmodel”，意思是「實驗機型」。後來為了與德國 V1 火箭區別，才改稱 Z1）。楚澤將 Z1 規劃為運算單元、記憶單元、控制單元、輸入／輸出單元，以及紙帶讀取器。這設計幾乎就是現代電腦的基本架構，唯一差別在於 Z1 的記憶單元只是用來貯存運算的數字，不像現代電腦的記憶單元也用來貯存程式。Z1 的運算程序和巴貝奇的分析機一樣，記錄在打孔紙帶上，再由讀取器傳送到控制單元（後來楚澤聽從朋友的建議，改用廢棄的電影膠卷，更便宜也更耐用）。

	L. 在廚房完成數位計算機的概念驗證——史提畢茲(George Stibitz), 1937 年 11 月的一個週末，史提畢茲把一些零件帶回家，就在廚房餐桌上組裝起來。他剪開菸草罐，裁出幾塊薄鐵片，用它們將兩個繼電器、電池，與燈泡固定在木板上，再用電線把它們連接起來，做出史上第一個繼電器組成的數位加法器。因為它是在廚房誕生的，史提畢茲的妻子乾脆把它取名為「型號 K」。因為史提畢茲只帶了兩套零件回家，所以只能輸入二進位的 01 或 10，相加的結果用兩個燈泡顯示，亮代表 1 ，暗代表 0。雖然這個加法器如此陽春，但它的意義在於「概念驗證」 (proof of concept)，證明了用繼電器建構的電路，可以成為一部數位計算器。史提畢茲相信只要給他更多繼電器，就能打造出加減乘除都能做的計算機。
	
	M. 阿塔納索夫 (John Vincent Atanasoff), 原子物理是阿塔納索夫的研究領域，他剛好知道英國物理學家溫-威廉斯 (C. E. Wynn-Williams) 於 1932 年用真空管電路打造二進位計數器，能以極高的速率偵測粒子，因此他決定也用真空管做為計算機的元件。不過真空管價格昂貴，如果全面採用，所需的資金恐怕他個人和學校都負擔不起。權衡之下，阿塔納索夫決定只有運算單元採用真空管，但記憶元件則使用電容器。電容器價格便宜許多，雖然充、放電的速度比較慢，但畢竟記憶單元的存取頻率不像運算單元那麼高，拖慢的速度尚可接受。唯一的問題是，電容器的電力很快就會流失，貯存的資訊也就跟著消失。阿塔納索夫一直想不出如何維持電容器的電力，一直到 1937 年 12 月的一個夜晚，他為了整理思緒開車上路，一路開到三百公里外的伊利諾州。他走進路邊一家酒吧，點了酒慢慢小酌，突然間靈光一閃，電容器的充電機制就在腦中浮現。這個關卡突破後，他隨即在餐巾上草擬出計算機的整體架構與基本規格。幾個小時後，阿塔納索夫步出酒吧，心滿意足地徐徐開車返家，準備展開全電子式數位計算機的打造計畫。

	N. 1938 年春, 貝爾實驗室的史提畢茲終於等到主管的答覆。發明「複數計算機」(Complex Number Calculator)用以處理電話通訊問題。史提畢茲針對複數計算的特性，設計成兩個運算單元同時運作，各自進行實部與虛部的計算。運算單元當然是使用繼電器，一共用了四百多個，但記憶單元則是改裝自現成的縱橫式交換機。 1940 年 9 月 11 日，「美國數學學會」(American Mathematical Society) 在達特茅斯學院 (Dartmouth College) 舉辦年會，史提畢茲上台展示已經運作好幾個月的複數計算器. 值得一提的是，有幾位即將在電腦發展中扮演重要角色的人物也在現場，包括馮紐曼、第一台通用型電子計算機的發明人莫奇利 (John Mauchly)，以及「模控學 (cybernetics) 之父」維納 (Norbert Wiener)。

	O. 貝爾實驗室，緊接著 Model V 推出精簡版的 Model VI 之後，就再也沒有投入計算機的開發。雖然如此，他們仍持續對電腦與網路做出許多重大貢獻，包括數據機、電晶體、行動網路、衛星通訊，乃至 UNIX 作業系統與 C 語言，都改變了數位時代的面貌。

	P. "哈佛架構", "馮紐曼架構"
	https://www.zhihu.com/question/586397018?write
		a. 馮紐曼在看過哈佛架構的電腦XXXXX後, 認為計算速度夠快但是前置作業很麻煩, 改变接线来进行部分运算的，这些开关用来实现逻辑运算和算数运算等。

也就是说这个时候是靠硬件接线来实现不同指令的计算的。

后来冯－诺依曼教授提出用同一套硬件，然后把指令和数据（软件）存储在硬件中（存储器），当需要进行不同指令计算的时候硬件就不用变了，直接调取不同的软件就行. 馮因此建議了一些東西, 其他人聽取建議後, 做出了一些改良, 此架構的功勞莫名其妙歸給了馮紐曼
		b. 兩架構基本差異:
		reference:
		https://www.zhihu.com/question/586397018?write
			I. 哈佛: 
				🤔. 程序和數據儲存空間(memory)分開, 
				🤔. 採用不同的總縣同時訪問指令和數據
			II. 馮紐曼:
				🤔. 程序和數據共用一個儲存空間(memory)
				🤔. 採用單一的地址和數據總線
				🤔. 馮額外提出的基礎架構, 更成了現代計算機的基本型態:
					😄. 输入设备(input)
						😄. 计算机软件其实就包含数据和指令，这些都通过输入设备输入。
					😄. 存储器(memory) --->現代的記憶體(內存)
						😄. 输入进来的数据和指令都存在存储器里面，准备被运算器和控制器调用。
					😄. 运算器(arithmetic logic unit) --->現代CPU的一部份
						😄. 运算器主要对数据进行运算，在控制器的控制下，读入数据，进行算数运算，逻辑运算等，主要单元是”算术逻辑单元（Arithmetic Logic Unit，ALU）”。
					😄. 控制器(control unit)  --->現代CPU的一部份
						😄. 从存储器中读取指令，然后执行指令，控制相关操作。运算器和控制器是CPU的主要部分，其实与计算机软件的数据与指令是相对应的。
					😄. 输出设备(ouput)
						😄. 把结果输出出去。
				🤔. 其架構主要思想是: 馮紐曼架構主要的精神是，必須要有記憶體以便存放資料與程式，且任一記憶體位址皆能任意地讀和寫；再者，必須要有計算與邏輯的運算能力；以及要有一控制單元負責記憶體與算術邏輯運算單元的資料傳送。因此，馮紐曼架構最大的特徵是，將程式編碼後儲存於記憶體中，視同將程式指令也變成「資料」，透過算術邏輯單元自記憶體中讀取指令來執行，從此奠定了電腦設計的基本原則。

				🤔. 馮紐曼瓶頸
				reference:
				https://blog.csdn.net/guojunxiu/article/details/79942905
					😄. 由於現代電腦通常CPU(control unit + ALU)比memory的速度快很多, 如果把指令和數據放在同一memory, 會導致讀取一次只能讀數據或是指令, 而通常數據比指令要多的多的多. 所以指令就要等數據從memory傳輸到CPU後才能傳輸, 這造成CPU資源浪費, 因為以CPU的速度其實可以同時處理兩者. 這種情況下哈佛架構更有優勢. 事實上現代計算機通常採用"Modified Harvard Architecture", 通常會在CPU和memory間加入cache(緩存)

			III. 哈佛架構似乎比逢紐曼架構更快, 為何現代計算機不採用?
			reference:
			https://www.zhihu.com/question/22406681/answer/3457529102

	Q. 圖靈機(Turin Machine)
		a. 二戰期間, 遠在大洋彼岸的英國, 有個高手也開始在思考類似的問題, 他就是圖靈. 其實圖靈一開始研究的是數學問題, 這個故事要從集合論開始說起.
			I. 康托爾提出集合論, 研究無限大的問題
			II. 羅素悖論提出集合論的缺陷
				🤔. 滿足性質P=P(x)=x∉x的所有元素的集合A, 請問A∈A?
					😄. if A∈A, then P(A)=A∉A, contradiction!!
					😄. if A∉A, 根據A的定義, A是所有滿足P的元素的集合, 所以A∈A, contradiction!
			III. 集合論被修改成"公里化集合論"
			IV. Hilbert思考竟然集合論需要公設化, 數學本身是否是完備的? 需要公設化? 一句數學陳述能否判定真假(無法判定表示就跟羅素悖論一樣, 無法判斷真或假)?
			V. 歌德爾不完備定理證明數學確實不完備
			VI. 圖靈開始思考Hilbert第三個問題, 如何判斷一個數學陳述是否可以判定真假
				🤔. 為解決此問題, 圖靈採用"圖靈機"的思路為出發點, 圖靈機基本抽象構造如下:
					😄. 一個無限長的條帶, 上面有無數方格(想像是1*∞的矩陣), 
					😄. 有一個讀寫頭, 每次操作都只能移動一格
					😄. 讀寫頭一次能在任意指定的方格內填入0或1, 或是讀取方格的數直
					😄. 方格內只有0或1
					😄. 操作表記錄了每一部操作的動作(這個其實就是編程的概念), 操作表的紀錄可以整理成一行行的操作指令
					😄. 若遇到矛盾的指令則"停機". 所謂矛盾是指例如「讀到 1 就往右；讀到 0 則往左」這個指令，就會讓圖靈機遇到 “1”、”0”相鄰時左右來回，永不停止(這其實就是類似羅素悖論的數學陳述). 這個"停機問題"也就是Hilbert的判定性問題. 圖靈即是要思考是否有程序可以判定某指令會造成"停機"
					😄. 圖靈利用類似康妥爾對角線法的方式證明了沒有任何程序可以判定某程序是否會停機, 也就是Hilbert的判定性問題, 答案也是否定的.

				🤔. 圖靈後來在二戰中主導了破解得過密碼機的工作, 開發了自己的計算機, N年後又提出了"圖靈測試", 被譽為人工智慧之父"
				🤔. 補充--->a universal Turing machine is a Turing machine capable of computing any computable sequence
	R. 二戰後
		a. 計算機硬體科學高速發展, IBM, 貝爾實驗室等等世界最先進的機構紛紛開發出磁性記憶體(硬碟前身)), 電晶體, 取代了真空管以及有的沒的

|#############################################################################################################|
2. 各種電腦:(除了量子電腦, 其他都太科幻了, 了解一下就好)
	A. 電子計算機(computer) ---> 現代意義的計算機
		a. 費林分類法(Flynny's Taxonomy)  --->詳細參考危機百棵吧
			I. 單一指令流單一資料流計算機（SISD）
			II. 單一指令流多資料流計算機（SIMD）
			III. 多指令流單一資料流計算機（MISD）
			IV. 多指令流多資料流計算機（MIMD）
	B. 生物計算機(biological computer)
	C. 化學計算機(chemical computer)
	D. 光子計算機(photon computer)
	E. 量子計算機(quantum computer)
	reference:
	關於量子計算機, 量子位元(qubit), 非常重要的一個影片, 講述了精采的原理
	https://www.youtube.com/watch?v=-UrdExQW0cs&ab_channel=Veritasium
		a. 量子波函數可以是疊加態, 一個qubit同時是1也是0, 我們在計算的時候, 事實上是1和0一起計算, 一般計算機如果有3 bit, 例如101, 我們計算就是計算101.  但在qubit之下是同時3 qubit是疊加態 a|000>+b|001>+c|010>+d|100>+e|011>+f|101>+g|110>+h|111>, 此波函數的疊加態他是一起同時計算的, 所以實際是同時計算a|000>, b|001>, c|010>, d|100>, e|011>, f|101>, g|110>, h|111>, 共有2^3=8個組合同時計算. 如果有n個qubit, 則同時計算的數目為2^n. 稱此為平行計算.
		b. 但由於我們測量波函數的時候, 波函數會隨機塌縮到某個eigenstate, 其他計算結果我們不會知道, 如何使平行計算的結果為己所用即是量子計算機的設計目標. 


|#############################################################################################################|
3. 電腦計算單元
	A. 基本單位:
		a. bit(1 or 0)
		b. Byte = 8 bit
		c. KB(Kilo-Byte) = 2^10 Byte = 1024 Byte(因為差不多為1000, 為了方便故稱其為Kilo)
		d. MB(Mega-Byte) = 2^10 KB = 1024^2 Byte(因為差不多為1000000, 故稱其為Mega)
		e. GB(Giga-Byte) = 2^10 MB = 1024^3 Byte
		f. TB = 2^10 GB = 1024^4 Byte
		g. PB = 2^10 TB = 1024^5 Byte

	B. 2, 8, 10, 16進制互轉, 
		a. 10->2(2->10就直接算就好了)
			I. 如果是整數基本就是用"連除法", 餘數要記錄, 這座幾次就會了, 新的商數當作被除數, 餘數當作結果值
			II. 如果是小數, 就採用"連乘法", 超過1的話, 整數部分去除並紀錄整數下來(為結果), 然後剩餘小數後面的數字繼續相同的方式直到小數規0(有可能無法歸零, 此表示用二禁制的話會有無限小數)

		b. 2->16或16->2
			I. 16=2^4, 所以4個bit為一單位轉換(16->2則1個單位轉回4個bit), 很簡單, 不用想的複雜
		c. 2->8或8->2
			II. 8=2^3, 所以3個bit為一單位轉換(8->2則1個單位轉回3個bit)

	B. 二補數(Two's Complement):
		a. 若用一個byte表示整數-127~127, 直觀作法是用XXXXXXX個bit, 第一個bit為0表示正, 為1表示負. 但這樣的作法有一點不大方便, 就是你把0XXXXXXX+1XXXXXXXX ≠ 00000000. 這不方便, 現代電腦通常採用"補數"的方法, 
			I. 一補數(補數)直接把0變1, 1變0. 若為二補數學(現代電腦使用), 先做完1補數, 然後+1, 正樣同值異號的兩個數, 加法剛好為0.
			I. 示例：用补码表示负数, 假设我们使用 8 位二进制来表示整数。
				🤔. 表示 -5
					😄. 正数5的原码表示：
						😄. 00000101
					😄. 求反码：
						😄. 11111010 （将每一位取反）
					😄. 求补码：
						😄. 11111010+1=11111011
					😄. 所以，-5 在 8 位二进制中的表示为：
						😄. 11111011

				🤔. 表示 -12
					😄. 正数12的原码表示：
						😄. 00001100
					😄. 求反码：
						😄. 11110011 （将每一位取反）
					😄. 求补码：
						😄. 11110011+1=11110100
					😄. 所以，-12 在 8 位二进制中的表示为：
						😄. 11110100
		b. 在二埔數的加法中, 若是超過範圍, 例如100+100=200>127, 則視為無效, 同樣<-127也視為無效
			I. 若符號bit在加法過程中發生溢位(符號位元, 也就是最左邊的位元, 從1變0或0變1), 則表示必定超過範圍
			II. 若是有進位且超出8 bit(假設最大為8 bit), 但是沒有溢位, 則可將超出8 bit的進位忽略, 剩餘的加法結果仍是正確答案


	


|#############################################################################################################|
3. 電腦硬體架構(主要是計算和記憶單元):
	A. CPU
		a. control unit
		b. 算術邏輯單元(Arithmetic Unit(AU) + Logical unit(LU))
		c. 暫存器(register)
			I. 指令暫存(Instruction Register)
			II. 程序計數暫存(Program Counter, PC)
			III. 通用暫存(general register)
			IV. 快取記憶體(cache memory), 用來當作CPU與主記憶體的橋樑, 速度比主記憶體快得多
		快取記憶體(cache memory)
	B. 記憶體:
		a. RAM(random access memory)
			I. DRAM(Dynamnic RAM)
			II. SRAM(Static RAM)
		b. ROM(read only memory, 唯讀記憶體. 他不是硬碟, 別搞混)
			I. 只能寫入資料一次, 通常用在bios或是一些嵌入式系統中
		
	C. 硬碟
		a. 傳統硬碟(就是用磁性物質當作硬碟)
		b. 固態硬碟(就是用記憶體當作硬碟)


|#############################################################################################################|
4. 數位邏輯設計:
	A. 基本符號(邏輯閘)  --->以下3個足夠構造所有閘
		a. 上頭加一個bar表示, 或使用"¬"表示: NOT, 優先及最高
		b. "•"或"∧"表示: AND, 優先及次之•   (∧長的像A, 所以為And, 記法)
		c. "+"表示"∨": OR, 優先及最後

	B. 常用符號(邏輯閘)
		d. NAND(NOT AND), 萬能閘, 一個人便能構造所有閘
			I. NAND(A,B)=¬(A∧B)
			II. 構造所有:
				🤔. NOT(A)=NAND(A,A)
				🤔. A∧B=NOT(NAND(A,B))
				🤔. A∨B=NAND(NOT(A),NOT(B))
		e. NOR(NOT OR), 也是萬能閘, 一個人便能構造所有閘
			I. NOR(A,B)=¬(A∨B)
		f. "⊕"表示: exclusive OR, XOR(異或), 及1 ⊕ 0 = 1, 0 ⊕ 1 = 1, 簡單來說就是輸入值不同時才輸出1, 有等式:
			I. X ⊕ Y = (NOT X)•Y+X•(NOT Y)		
		g. exclusive NOR, XNOR(同或), 當輸入值相同時, 輸出為1


	C. 布林函數(boolean function) and 真值表(truth table)
		a. Boolean function表示: F(X, Y, Z) = (X AND NOT Y) OR Z........組合而成
		b. truth table表示: 把所有可能的情況都列出

	D. 邏輯閘diagram實作(把布林函數轉換成邏輯閘diagram), 各個邏輯閘的圖自己上網找
		a. 畫圖大原則(不一定百分百適用所有狀況)
			I. 最終的輸出總是在最右邊
			II. 優先級相同的閘(布林函數中優先級相同的運算符號), 縱向對齊(垂直對齊)
			III. 由左到右 優先級 降低, 最右邊的會是優先級最低的(也就是布林函數中最晚計算到運算符號)

		b. 實例
			I. 加法器,  X, Y, SUM, CARRY
				🤔. SUM(X, Y) = X ⊕ Y   ------>X, Y兩個不一樣, 才是1
				🤔. CARRY(X, Y) = X • Y   ------->X, Y都是1及表示進位
			II. 全加法器,  X, Y, C_in(前一位的進位), SUM, C_out(包含C_in的進位), 
				🤔. SUM(X, Y, C_int) = A ⊕ B ⊕ C_in = (A ⊕ B) ⊕ C = A ⊕ (B ⊕ C)
				🤔. C_out(X, Y, C_int) = (A∧B)∨(B∧C_in)∨(A∧C_in)
					
				
			
















參考書:
https://web.csie.ndhu.edu.tw/sclo/project/ppt.html
