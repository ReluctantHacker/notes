#############################################################################################################
1. some datastructure
	A. primitive: integer, float, string, boolean
	B. non-primitive: 
		a. ç·šæ€§(in sequential order): list, tuple, array, linked list, stack, queue
		b. éç·šæ€§: set, dictionary, tree, graph

#############################################################################################################
2. Program Complexity
	A. Space complexity

	B. Time complexity
		a. f âˆˆ o(g)  ---   order(f)<order(g)  ---  lim f(x)/g(x) = 0 , x->âˆ
		a. f âˆˆ O(g)  ---   order(f)â‰¤order(g)  ---  lim f(x)/g(x) < âˆ , x->âˆ
		a. f âˆˆ Ï´(g)  ---   order(f)=order(g)  ---  lim f(x)/g(x) âˆˆ R > 0 , x->âˆ
		a. f âˆˆ Î©(g)  ---   order(f)â‰¥order(g)  ---  lim f(x)/g(x) > 0 , x->âˆ
		a. f âˆˆ Ï‰(g)  ---   order(f)>order(g)  ---  lim f(x)/g(x) = âˆ , x->âˆ

#############################################################################################################
3. Recursive Algorithm(basic)
	A. Factorial
	B. Fibonacci Number
	C. Greatest Common Divisor(GCD)
	D. Binomial Coefficient
	E. Ackerman's Function
	F. Tower of Hanoi
	G. Permutation


#############################################################################################################
4. array
	A. first dimensional array
	B. second dimensional array
		æ²’è€ƒé
	C. third dimensional array
		æ²’è€ƒé

#############################################################################################################
5. linked list
	A. å„ªé»
		a. å‹•æ…‹æ€§: å‹•æ…‹å¢åŠ ç©ºé–“, ä¸éœ€è¦ä¸€é–‹å§‹è¨­å®šå¥½
		b. éé€£çºŒæ€§: ä¸éœ€è¦é€£çºŒçš„å„²å­˜ç©ºé–“
		c. æ’å…¥å…ƒç´ , æˆ–åˆªé™¤å…ƒç´ æ•ˆç‡é«˜: æ™‚é–“è¤‡é›œåº¦O(1)

	B. ç¼ºé»:
		a. éš¨æ©Ÿè¨ªå•æ•ˆç‡ä½: éœ€è¦å¾é ­æŸ¥æ‰¾, æ™‚é–“è¤‡é›œåº¦O(n)
		b. å ç”¨é¡å¤–çš„ç©ºé–“
	
#############################################################################################################
6. stack
	A. ADT
		a. æ€§è³ª:
			I. First in Last out(FILO)

		b. æ“ä½œ:
			I. push(): push an element in stack's top position
			II. pop(): return the the top element and remove it from the stack
			III. peek(): return the top element
			IIII. isempty(): return if stack is empty or not
			IIIII. size(): return how many data in stack
			ps: åŸºæœ¬ä½ æœƒç™¼ç¾stack push, pop éƒ½æ˜¯å°topä½œç”¨, æ‰€ä»¥å¢åˆªéƒ½åœ¨åŒä¸€å€‹ä½ç½®
	B. array å¯¦ä½œ
		a. å¯¦ä½œè¦é»:
			I. ä¸€å€‹array, é•·åº¦ä¾éœ€æ±‚
			II. ä¸€å€‹int top, ç´€éŒ„topçš„ä½ç½®
			III. topçš„åˆå§‹åŒ–ç‚º-1, pushå‰‡+1, popå‰‡-1

	C. linked listå¯¦ä½œ:
		a. å¯¦ä½œè¦é»:
			I. ä¸€å€‹data
			II. ä¸€å€‹*next, æŒ‡å‘ä¸‹ä¸€å€‹node
			III. åˆå§‹nodeç‚ºNULL
			IIII. èˆ‡arrayå¯¦ä½œçš„æ–¹å‘ç›¸å, åœ¨headerçš„åœ°æ–¹push(ä¹Ÿpop), 
			IIIII. header nodeä»£è¡¨äº†é€™å€‹stack
			IIIIII. NULL node ä»£è¡¨é€™å€‹stackçš„çµæŸä½ç½®

#############################################################################################################
6. ä¸­åºå¼èˆ‡(å¾Œåºå¼ or å‰åºå¼)äº’è½‰çš„æ¼”ç®—æ³•
	A. infix -> postfix
		a. éœ€è¦1å€‹stack
		b. ç”±å·¦å‘å³scan
		c. æŠŠ"ç®—ç¬¦"push(pop)åˆ°stack(stackåªæœƒéœ€è¦å­˜ç®—ç¬¦)
	B. postfixçš„è¨ˆç®—æ¼”ç®—æ³•
		a. éœ€è¦1å€‹stack
		b. ç”±å·¦å‘å³scan
		b. æŠŠ"æ•¸å­—"push(pop)åˆ°stack(stackåªæœƒéœ€è¦å­˜æ•¸å­—)
	C. infix -> prefix
		a. éœ€è¦2å€‹stack
		b. ç”±å³å‘å·¦scan
		c. ä¸€å€‹stackæ˜¯temp, ä¸€å€‹æ˜¯result
	D. prefixçš„è¨ˆç®—æ¼”ç®—æ³•
		a. éœ€è¦1å€‹stack
		a. ç”±å³å‘å·¦scan
		c. æŠŠ"æ•¸å­—"push(pop)åˆ°stack(stackåªæœƒéœ€è¦å­˜æ•¸å­—), è·Ÿpostfixå¾ˆåƒ, åªæ˜¯è¨ˆç®—æ™‚çš„æ¬¡åºè¦æ³¨æ„


#############################################################################################################
7. Queue
	A. ADT
		a. æ€§è³ª:
			I. First in First out(FIFO)

		b. æ“ä½œ:
			I. enqueue(): push an element in queue's rear position
			II. dequeue(): return the the front element and remove it from the queue
			III. isfull(): return if queue is full or not
			IIII. isempty(): return if queue is empty or not
			IIIII. front(): return the front element of the queue
			ps: åŸºæœ¬ä½ æœƒç™¼ç¾queue push, pop åˆ†åˆ¥åœ¨é ­å’Œå°¾, æ‰€ä»¥å¢åˆªåœ¨ä¸åŒä½ç½®
	B. array å¯¦ä½œ
		a. å¯¦ä½œè¦é»:
			I. ä¸€å€‹array, é•·åº¦ä¾éœ€æ±‚
			II. ä¸€å€‹int front, ç´€éŒ„frontçš„ä½ç½®
			III. ä¸€å€‹int rear, ç´€éŒ„rearçš„ä½ç½®
			III. front, rearçš„åˆå§‹åŒ–çš†ç‚º-1, enqueueå‰‡rear++, dequeueå‰‡rear-1, frontä¸è®Š

	C. linked listå¯¦ä½œ:
		a. å¯¦ä½œè¦é»:
			I. ä¸€å€‹data
			II. ä¸€å€‹*next, æŒ‡å‘ä¸‹ä¸€å€‹node
			III. éœ€è¦ä¸€å€‹front nodeå’Œä¸€å€‹rear node, å…©å€‹æ‰“åŒ…æˆä¸€å€‹queue
			III. åˆå§‹front node å’Œ rear node çš†ç‚ºNULL
			IIII. rear node enqueue, front node dequeue
			IIIII. NULL node ä»£è¡¨é€™å€‹queueçš„çµæŸä½ç½®


#############################################################################################################
7. Priority Queue
	A. ADT
		a. æ€§è³ª:
			I. ä¸ä¸€å®šFirst in First out(FIFO)
			II. enqueueä»»æ„å…ƒç´ (æ¬Šå€¼)
			III. dequeueæœ€å¤§/æœ€å° æ¬Šå€¼çš„å…ƒç´ 

		b. æ“ä½œ:
			I. åˆ©ç”¨heap tree(ç°¡ç¨±heap), 
				ğŸ¤”. å®šç¾©
					ğŸ˜„. ç‚ºä¸€complete binary tree(æ•…å¿…å®šå¹³è¡¡)
					ğŸ˜„. çˆ¶nodeå¿…å®šæ¯”å­nodeå¤§(max heap, åä¹‹å‰‡ç‚ºmin heap), 
					ğŸ˜„. æ‰€æœ‰å­nodeçš†ç¬¦åˆä¸Šè¿°å®šç¾©
			ps: heapå’Œheap sortå¤§æœ‰é—œä¿‚!!!!


#############################################################################################################
8. Binary Tree(Tree ä¹Ÿå±¬æ–¼ graph)
	A. ç¸½æ€§è³ª:
		a. ä»»æ„treeå¯åŒ–ç‚ºbinary tree
		b. ä»»æ„nodeæœ€å¤šåªæœ‰å…©å€‹degree(åˆ†æ”¯)
		c. å·¦å³å­æ¨¹æœ‰æ¬¡åºä¹‹åˆ†(ä¸€èˆ¬treeæ²’æœ‰ç‰¹åˆ¥å®šç¾©)

	B. Full binary tree
		a. æ€§è³ª:
			I. å¿…å®šå¹³è¡¡
			II. é™¤äº†leafä»¥å¤–, æ‰€æœ‰nodeç•¶æˆrootçš„å­æ¨¹éƒ½å¿…å®šç‚ºfull binary tree
			III. æœ€å¾Œä¸€å€‹levelå¡«æ»¿
			IIII. å…¬å¼:
				ğŸ¤”. N = 2^H - 1   ç­‰åƒ¹æ–¼  log_2(N+1) = H, N=nodeæ•¸, Hç‚ºé«˜åº¦
				ğŸ¤”. lN = 2^(H-1)

	C. Complete binary tree
		a. æ€§è³ª:
			I. å¿…å®šå¹³è¡¡
			II. é™¤äº†leafä»¥å¤–, æ‰€æœ‰nodeç•¶æˆrootçš„å­æ¨¹ä¹Ÿéƒ½å¿…å®šç‚ºcomplete binary tree
			III. æœ€å¾Œä¸€å€‹levelæœªå¿…å¡«æ»¿, ä½†æ˜¯ä¸€å®šç”±å·¦åˆ°å³å¡«å…¥, ä¸æœƒæœ‰è·³é
			IIII. å…¬å¼: log_2(N+1) = H, ç„¡æ¢ä»¶é€€ä½

	D. Pathological Tree
		a. æ€§è³ª:
			I. H = N, H=é«˜åº¦, N=nodeæ•¸
		b. left-skewed binary tree
		c. rigth-skewed binary tree

	E. å¯¦ä½œ
		a. ä½¿ç”¨array
			I. å„ªé»:
				ğŸ¤”. å°æ–¼full B.Tå®Œå…¨æ²’æœ‰æµªè²»ç©ºé–“
				ğŸ¤”. å®¹æ˜“å–å¾—æŸnodeä¹‹å·¦å³å­node, ä»¥åŠçˆ¶nodeçš„è³‡æ–™
					ğŸ˜„. æŸnodeçš„ç·¨è™Ÿç‚ºiå‰‡:
						ğŸ˜„. å·¦å­nodeç·¨è™Ÿç‚º2i, if 2i>N, å·¦å­nodeä¸å­˜åœ¨
						ğŸ˜„. å³å­nodeç·¨è™Ÿç‚º2i+1, if 2i+1>N, å³å­nodeä¸å­˜åœ¨
						ğŸ˜„. çˆ¶nodeç·¨è™Ÿç‚º[i/2]([]:ç„¡æ¢ä»¶æ¨ä½), if [i/2]<1, å‰‡çˆ¶nodeä¸å­˜åœ¨
			II. ç¼ºé»:
				ğŸ¤”. ç¯€é»å¢åˆªä¸æ˜“, è‹¥ç©ºé–“ä¸æ§‹, è¦é‡æ–°å®£å‘Šarray
				ğŸ¤”. skewed B.Tæ¥µåº¦æµªè²»ç©ºé–“

		b. ä½¿ç”¨linked list(å¤§éƒ¨åˆ†å¯¦ä½œé‚„æ˜¯ç”¨é€™å€‹)
			I. å„ªé»: 
				ğŸ¤”. nodeå¢åˆªå®¹æ˜“
				ğŸ¤”. å°æ–¼skewed B.T
			II. ç¼ºé»: 
				ğŸ¤”. ä¸æ˜“å–å¾—çˆ¶node
					ğŸ˜„. å› ç‚ºæ¯å€‹nodeåªå­˜å·¦å­nodeä»¥åŠå³å­node
				ğŸ¤”. linkç©ºé–“ä»æµªè²»ç´„ä¸€åŠ
					ğŸ˜„. å› ç‚ºæ‰€æœ‰leafçš„linkçš†æ²’æœ‰ç”¨åˆ°
			III. å¯¦ä½œ:
				ğŸ¤”. æ¯å€‹nodeçš†éœ€è¦
					ğŸ˜„. data
					ğŸ˜„. left child node(cèªè¨€å¯ç”¨æŒ‡æ¨™)
					ğŸ˜„. right child node(cèªè¨€å¯ç”¨æŒ‡æ¨™)
				ğŸ¤”. rootä»£è¡¨äº†é€™æ£µæ¨¹
			
	 
#############################################################################################################
9. Binary Tree Traversal(æ“ä½œä¸Šå¹¾ä¹éƒ½ä½¿ç”¨recursive)
	A. breadth first(å»£åº¦å„ªå…ˆ) Traversal
		a. ç”±å·¦åˆ°å³
		b. å†ç”±ä¸Šåˆ°ä¸‹
		c. ç°¡å–®ä¾†èªªå°±æ˜¯åŒä¸€levelçš„å…ˆè™•ç†å®Œå†è™•ç†ä¸‹ä¸€å€‹level

	B. Depth first(æ·±åº¦å„ªå…ˆ) Traversal
		a. å‰åº(preorder, DLR) Traversal, preorderTrav()
			I. æ¡ç”¨recursive
			II. time complexity: O(n)

		b. ä¸­åº(inorder, LDR) Traversal, inorderTrav()
			I. æ¡ç”¨recursive
			II. time complexity: O(n)

		c. å¾Œåº(postorder, LRD) Traversal, postorderTrav()
			I. æ¡ç”¨recursive
			II. time complexity: O(n)

		d. çµ¦(inorderå’Œpreorder)æ’åºçµæœ, å›æ¨binary tree
			I. preorderçš„rootå¿…å®šåœ¨æœ€å‰é¢
			II. inorderçš„rootå¿…å®šåœ¨å·¦å³å­treeçš„inorderä¸­é–“
			III. é‡è¤‡I, II

		c. çµ¦(inorderå’Œpostorder)æ’åºçµæœ, å›æ¨binary tree
			I. postorderçš„rootå¿…å®šåœ¨æœ€å¾Œé¢
			II. inorderçš„rootå¿…å®šåœ¨å·¦å³å­treeçš„inorderä¸­é–“
			III. é‡è¤‡I, II

		d. çµ¦(preorderå’Œpostorder)æ’åºçµæœ, å›æ¨binary tree
			I. å¯èƒ½æœ‰å¾ˆå¤šç¨®çµæœ, æ•…ç„¡æ³•

		e. è¨ˆç®—B.T node ç¸½æ•¸, count()
			I. æ¡ç”¨recursive

		f. è¨ˆç®—B.T é«˜åº¦, height()
			I. æ¡ç”¨recursive

		g. B.Tæ¯ä¸€nodeå·¦å³å­treeäº¤æ›, swap()
			I. æ¡ç”¨recursive

		
#############################################################################################################
10. Binary search tree
	A. å®šç¾©:
		a. å·¦å­æ¨¹æ‰€æœ‰Nodeéµå€¤å‡å°æ–¼Rootéµå€¤
		b. å³å­æ¨¹æ‰€æœ‰Nodeéµå€¤å‡å¤§æ–¼Rootéµå€¤
		c. å·¦ã€å³å­æ¨¹äº¦æ˜¯Binary Search Tree

	B. å»ºç«‹:
		a. æº–å‚™ä¸€æ®µè³‡æ–™, ä¾‹å¦‚array
		b. å°‡arrayçš„é¦–å€‹è³‡æ–™ç•¶ä½œroot
		c. æ¥è‘—æŒ‰ç…§binary search treeå®šç¾©ä¾åºå¡«å…¥
		d. å¹³å‡æ™‚é–“è¤‡é›œåº¦: O(nlog n)
			I. æ¨å°:
				ğŸ¤”. total time complexity = log(1) + log(2) + log(3) + ... log(n) = log(n!)
				ğŸ¤”. log(n!) = nlog(n) when n->âˆ, according to stirling formula(use intergral)
		e. æœ€å·®æ™‚é–“è¤‡é›œåº¦: O(n^2)
 
	C. æŸ¥æ‰¾(search)
		a. æœ€å£æƒ…æ³O(n), é€™æ£µæ¨¹å‰›å¥½æ˜¯skewed tree
		b. å¹³å‡æƒ…æ³O(log n)

	D. æ’å…¥(insert)
		a. æœ€å£æƒ…æ³O(n)
		b. å¹³å‡æƒ…æ³O(log n)

	E. åˆªé™¤(delete)
		a. æœ€å£æƒ…æ³O(n)
		b. å¹³å‡æƒ…æ³O(log n)

	F. æ’åº(sort), BSTä¹Ÿå¯ä»¥ç”¨æ–¼æ’åº(ä½†è³‡æ–™å¿…é ˆå…ˆå»ºç«‹æˆBST)
		a. ç”¨inorder traversal, å³å¯å¾—åˆ°"ç”±å°åˆ°å¤§"çš„æ’åºçµæœ
		b. æ™‚é–“è¤‡é›œåº¦è‡ªç„¶æ˜¯traversalçš„è¤‡é›œåº¦O(n)
		c. åœ¨tree sortå¯¦ä½œä¸­, éœ€è¦æŠŠ"create tree"çš„è¤‡é›œåº¦ä¹Ÿç®—é€²ä¾†, æ‰€ä»¥ç¸½å…±é‚„æ˜¯è¦O(nlog(n))

	
#############################################################################################################
11. Tree æˆ– forest åŒ– Binary tree
	A. Tree åŒ– binary tree
		a. siblingä¹‹é–“å»ºç«‹link
		b. æ¯ä¸€å€‹nodeåªä¿ç•™æœ€å·¦å­nodeçš„linkå’Œå‰›æ‰å»ºç«‹çš„sibling link, å…¶é¤˜linkçš†æ–·

	B. Forest(many unlinked tree) åŒ– binary tree
		a. æ‰€ä»¥treeçš†åŒ–binary tree
		b. å°‡binary treeså€‘çš„rootå»ºç«‹link
		c. ä»¥ç¬¬ä¸€é¡†treeçš„rootç‚ºæ–°root


#############################################################################################################
12. åœ–(Graph), åˆ©ç”¨é›†åˆ(set)çš„æ¦‚å¿µæœƒå¾ˆå¥½ç†è§£
	A. ç„¡å‘åœ–(undirected graph)
		a. G=(V, E), V=vertex, E=edge
		b. Eé€šå¸¸è¡¨ç¤º(vi, vj), å…¶ä¸­vi, vjç‚ºå…©ç›¸é„°vertex
		b. (vi, vj) != (vj, vi)

	B. æœ‰å‘åœ–(directed graph)
		a. G=(V, E), V=vertex, E=edge
		b. Eé€šå¸¸è¡¨ç¤º(vi, vj), å…¶ä¸­vi, vjç‚ºå…©ç›¸é„°vertex
		c. (vi, vj) != (vj, vi)

	C. å®Œæ•´åœ–(complete graph)
		a. ç„¡å‘åœ–çš„å®Œæ•´åœ–
			I. æ‰€æœ‰vertexéƒ½èˆ‡å…¶ä»–vertexå½¢æˆä¸€å€‹edge
			II. è‹¥æœ‰nå€‹vertex, å‰‡å…±æœ‰n(n-1)/2å€‹edge
		b. æœ‰å‘åœ–çš„å®Œæ•´åœ–	
			I. æ‰€æœ‰vertexéƒ½èˆ‡å…¶ä»–vertexå½¢æˆå…©å€‹(ä¾†å›)æœ‰å‘é‚Šedge
			II. å¦‚æœ‰nå€‹vertex, å‰‡å…±æœ‰n(n-1)å€‹edge

	D. å­åœ–(subgraph)	
		a. é›†åˆV(G') å±¬æ–¼ é›†åˆV(G) ä¸” é›†åˆE(G') å±¬æ–¼ é›†åˆE(G), å‰‡G'ç‚ºGçš„subgraph

	E. è·¯å¾‘(path)
		a. å®šç¾©:
			I. vertex våˆ°v', ç¶“éçš„æ‰€æœ‰edgeçš„é›†åˆ
		b. é•·åº¦(path length):
			I. edgeçš„å€‹æ•¸
		c. ç°¡å–®è·¯å¾‘(simple path):
			I. é™¤äº†é ‚é»å’Œçµ‚é», å…¶ä»–é»çš†ä¸åŒ
				ğŸ¤”. è‹¥é ‚é»å’Œçµ‚é»ç›¸åŒç¨±ç‚º"è¿´åœˆ(cycle)"

	F. é€£é€š(connected)
		a. for ç„¡å‘åœ–
			I. ä»»æ„vertexèˆ‡ä»»æ„vertexä¹‹é–“çš†æœ‰pathå­˜åœ¨, å³è¡¨ç¤ºæ­¤åœ–connected

		b. for æœ‰å‘åœ–
			I. å¼·é€£é€š(strongly connected)
				ğŸ¤”. ä»»æ„vertexèˆ‡ä»»æ„vertexä¹‹é–“çš†æœ‰path(é›™å‘)å­˜åœ¨
			II. å¼±é€£é€š(weakly connected)
				ğŸ¤”. ä»»æ„vertexèˆ‡ä»»æ„vertexä¹‹é–“çš†æœ‰path(å–®é …æˆ–é›™å‘)å­˜åœ¨
				ğŸ¤”. ä½†æ˜¯è‡³å°‘æœ‰ä¸€å°vertexä¹‹é–“åªæœ‰å–®å‘path(åªèƒ½å¾€, ä¸èƒ½è¿”)
			III. ä¸ç›¸é€£(disjoint)
				ğŸ¤”. ä¸¦éä»»æ„vertexä¹‹é–“çš†æœ‰path(å–®å‘æˆ–é›™å‘)
				ğŸ¤”. åœ–å¯ä»¥åˆ†æˆä¸ç›¸é€£çš„å­åœ–
				ğŸ¤”. 
		
	
