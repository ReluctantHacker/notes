|#############################################################################################################|
1. 資料庫的基本類型:
	A. 階層式
		a. 樹結構
		b. 例如: file system
	B. 網狀式
		b. 網狀結構, node之間可以互聯
	C. 關聯式
		c. sql類型, 也是最廣泛使用的
	D. 物件導向式
		d. 使用程式語言中class的概念來儲存數據

|#############################################################################################################|
2. 資料庫的架構
	A. 單機
	B. 終端
	C. 主從(client-server)
		a. 就是一般常見的架構
	D. 分散式
		a. 由多台數據庫server組合而成, 
		b. 使用者在存取資料時, 資料可以來自於不同的伺服器中
		c. 效率較好, server負擔較小, 但也較難建立
		d. 透明度:
			I. 在分散式系統中，透明度（Transparency）指的是系統對用戶或應用程序隱藏了其內部的細節，使其感覺就像是在使用單一的、統一的系統。透明度旨在簡化系統的使用和管理，使得用戶和應用程序可以將注意力集中在功能和應用上，而不必關心底層的實現細節。透明度通常包括以下幾個方面：

				🤔. 存取透明度（Access Transparency）：
					😄. 使用者無需關心資料的存儲位置和具體的存取方式，只需通過統一的接口來訪問資料。
				🤔. 位置透明度（Location Transparency）：
					😄. 使用者不需要知道資料或服務的實際位置，可以通過統一的命名來訪問它們。即使資料或服務的位置發生變化，使用者也不會受到影響。
				🤔. 移動透明度（Mobility Transparency）：
					😄. 使用者可以在系統中自由地移動，而不會影響其訪問資料或服務的能力。系統能夠自動地處理資源的移動和重新配置，而不需要用戶干預。
				🤔. 重定向透明度（Redirection Transparency）：
					😄. 系統可以根據負載情況和資源可用性，自動地將請求重定向到最合適的資源或服務上，用戶不需要手動干預。
				🤔. 故障透明度（Failure Transparency）：
					😄. 系統可以自動地處理故障和錯誤，並提供恢復機制，使得用戶無需感知到系統的故障或錯誤。


|#############################################################################################################|
3. ER Model(ER digram)
reference:
關於圖形代號的完整說明如下參考:
https://www.conceptdraw.com/examples/erd-double-line
弱實體的連接, "完全參與", "部分參與":
https://faculty.stust.edu.tw/~jehuang/oracle/ch2/2-1.htm
一個討論:
https://stackoverflow.com/questions/19781294/whats-the-difference-in-notation-for-total-participation-and-recursive-relation

	A. Chen's notation (以下整理比較容易忘記或混淆的一些概念)
		a. 弱實體(weak entity)
			I. 所謂弱實體就是必須依賴於其他實體而存在, 例如在學生資料庫中"學生家長"實體依賴於"學生"實體, A學生若從資料庫清除了, A學生的家長自然也就不存在
			II. 使用雙矩形(外面加邊框)表示
		b. 弱關係: 實體和弱實體之間關係用雙菱形(外面加邊框)表示(一班的只用普通菱形)

		c. "推導屬性"即是可從其他屬性推導出來, 例如星座可從出生日期推導.  推導屬性用"虛線橢圓"表示

		d. "多值屬性" 即是擁有很多值得屬性, 例如專長屬性, 可以有好幾種專長, 多值屬性用"雙橢圓(加邊框)"表示

		e. "total participation", "partial participation"
		reference:
		https://faculty.stust.edu.tw/~jehuang/oracle/ch2/2-1.htm
			I. 我們知道, A, B兩個entities 之間有一個"關係"R, 若A裡面的instance必定完全參加R則 稱A完全參與R(total participation), 用"double line"表示, 若instance不需要完全參加R則表示部分參加(partial participation), 用single line表示, B也是一樣的
			II. 弱實體(weak entity)C必定依附於一個實體D, 他們之間的關係R, C必定完全參加R(但是D不見得完全參加R), 所以weak entity在ER圖中, 至少有一條double line, 且此double line指向的關係必定是依附於他的"母親"entity

	B. Crow's foot

	C. ERD設計的三個原則, 就是...
		a. 找出並條列出所有entity
		b. 找出並條列出所有實體對應的所有attributes
		c. 找出所有entity之間的關聯, 並條列出來
		d. 按照條列劃出ERD

	D. 實際設計範例題目:
		https://medium.com/pierceshih/%E7%AD%86%E8%A8%98-%E5%AF%A6%E9%AB%94%E9%97%9C%E8%81%AF%E5%9C%96-87c3ecbc5ff0
		https://www.mis.nsysu.edu.tw/db-book/pro_ch3.html

	E. EER model(enhance ER model)
	reference:
	http://uml.org.cn/sjjm/Chapter10-4.pdf


|#############################################################################################################|
4. 資料庫設計
	A. 正規化(normalization)
	reference:
	https://stackoverflow.com/questions/723998/what-are-database-normal-forms-and-can-you-give-examples/724032#724032
		a. 第一正規化: 把可以拆分的欄位拆出, 且不能有重複的資料(一樣)的資料, 也就是需要有primary key
			I. Every non-key attribute should be dependent on the key
		b. 第二正規化: 部分相依於primary keys的欄位必須獨立出去
			I. Every non-key attribute should be dependent on the key and the whole key
		c. 第三正規化: 欄位本身不相依於primary keys, 但她所相依的欄位卻完全相依於primary keys, 這樣的欄位也要獨立出去
			I. Every non-key attribute should be dependent on the key, the whole key and nothing but the key
		d. BCNF ---> Every attribute(including non-key or key attribute) should be dependent on the key, the whole key and nothing but the key
		reference:
		以下的解釋有一個精采的範例
		https://www.youtube.com/watch?v=VWnKUKH4tLg
		另一個解釋, 但不是很好(範例有問題!)
		https://stackoverflow.com/questions/8437957/difference-between-3nf-and-bcnf-in-simple-terms-must-be-able-to-explain-to-an-8

			I. "candidate keys(候選鍵)"----可以唯一決定record的欄位集合(可能有很多種),不接受冗餘欄位, candidate keys 為super keys的子集合
			II. "super keys(超鍵)"----可以唯一決定record的欄位集合(可能有很多種), 接受冗餘欄位.
			III. "functional dependency(函數相依)"---- Y依賴X, 記做 X -> Y
			IIII. "closure(閉包)"----一樣是集合論的概念, 假設一個集合S裡的元素, 經過F運算後仍然在該集合中, 則我們稱"這集合S在F運算下閉合(closed)", 當一個集合 S 在某個運算下不閉合的時候，我們通常可以找到包含 S 的最小的閉合集合。這個最小閉合集合被稱為 S 的（關於這個運算的）閉包(closure)!!!!

		e. 在已知依賴關係的情況下candidate keys的找法(記住, candidate keys是super keys的最小子集合, 當然可能有很多個, 我們把所有的super keys找出, 自然能發現candidate keys)
			🤔. question1:
				R = {A, B, C, D, E}, function dependencies are: A->B, ED->A, BC->E, 則candidates keys為{A, C, D}, {B, C, D}, {C, D, E}
	
				Solution:
					其實很簡單, 一步一步做就很清楚了
					首先找出所有沒有考慮相依性的superkeys(其實就只有R本身而已)
					{A, B, C, D, E} 
					在找出只考慮一個相依性的superkeys
					{A, C, D, E} (在這裡我們替除了B, 因為A->B, B依賴A)
					{B, C, D, E} (在這裡我們替除了A, 因為ED->A, A依賴ED)
					{A, B, C, D} (在這裡我們替除了E, 因為BC->E, E依賴BC)
					接著按照上面的結果, 再多考慮一個相依性的superkeys
					{C, D, E} (在這裡我們從{A, C, D, E}出發, 考慮了ED->A)
					{B, C, D} (在這裡我們從{B, C, D, E}出發, 考慮了BC->E)
					{A, C, D} (在這裡我們從{A, B, C, D}出發, 考慮了A->B)
					接下來無法再依照相依性剔除任何元素了...所以superkeys為以下:
					{A, B, C, D, E}, {A, C, D, E}, {B, C, D, E}, {A, C, C, D}, {C, D, E}, {B, C, D}, {A, C, D}
					candidate keys為最小的子集合, 所以如下:
					{C, D, E}, {B, C, D}, {A, C, D}

			🤔. question2:
				R = {A, B, C, D}, function dependencies are: D->B, AB->D, AB->C, C->A, 則candidates keys為{C, D}, {A, B}, {B, C}, {A, D}

				solution: 
					一樣, 與上一題一模一樣的方式,找出所有superkeys
					{A, B, C, D}
					{A, C, D} (根據D->B) 
					{A, B, C} (根據AB->D)
					{A, B, D} (根據AB->C)
					{B, C, D} (根據C->A)
					{C, D} (根據D->B, C->A)
					{A, B} (根據AB->D, AB->C)
					{B, C} (根據AB->D, C->A)
					{A, D} (根據AB->C, D->B)
					{A, B} (根據AB->C, AB->D)
					{C, D} (根據C->A, D->B)
					剔除重複的狀況後, 得到candidate keys為
					{C, D}, {A, B}, {B, C}, {A, D}	

	C. 索引(index):
		a. 基本解釋: 為何可以增加搜索數據的速度, 其實不難理解, 資料存入資料庫若是沒有任何資料結構, 那搜索將採用線性搜索, 也就是時間複雜度是O(n), 如果做了B-Tree(balanced m-way search tree)的索引結構, 那搜索速率自然提升到O(log(n)) 

		b. 缺點:  雖然索引(index)會使搜索效率提升, 但是insert, 或update的速率是會下降的, 因為他需要先找到, 才能插入或update, 但是沒做索引的話, 直接插入就好, 不用理會index的結構到底如何

		c. 叢集索引(cluster index), 非叢集索引(non-cluster index)
		reference: 
		https://www.youtube.com/watch?v=YuRO9-rOgv4
			I. 要理解這裡兩者的區別, 我們得先知道B+樹, 首先大部分的索引其實都使用B+樹(前面提到B-Tree, 只是方便說明, 其實應該是B+ tree), B+樹為了減小樹高(增加search效率), 而把值都存在葉節點, 其他節點只存key...
			II. 叢集索引的排列順序就是實際上(物理上)資料的排列順序(由於在實際物理上做了B+ tree結構, 所以更快)，而非叢集索引的排列順序不會/無法影響到實際資料的排列順序。 也因此，一個資料表中可以包含很多非叢集索引, 但只會有一個叢集索引。
			III. cluster新增資料較慢, 但查詢較快, noncluster新增資料較快, 但查詢較慢(兩者都比不做索引要快)


|#############################################################################################################|
5. transaction(交易)
沒時間了...除了講義以外, 記得看以下reference:
https://zhuanlan.zhihu.com/p/133823461
	A. ACID(Atomicity, Consistency, Isolation, Durability)
	reference:
	https://lance.coderbridge.io/2021/04/24/short-what-is-acid/

		a. Atomicity
			I. Transaction為最小單元, 不可再分割, Transaction內的運算只能一起成功或一起失敗
		b. Consistency
			I. Transaction的運算必須與現實世界的規則一致
		c. Isolation
			I. Transaction之間互相獨立, 彼此不會互相影響
		d. Durability
			I. Transaction commit 後, 其運算結果應在具有持久性

	B. Transaction的執行:
		a. 概念上, 一個交易是由數個以下五種基本運算動作所組成：
			I. begin(T)：表示一個交易T開始執行。
			II. read(X, x)：表示從硬碟讀取資料項X到主記憶體變數x。
			III. write(x, X)：表示將主記憶體變數x寫至硬碟資料項X。
			IV. commit(T)：表示一個交易T成功的結束。
			V abort(T)：表示一個交易T被駁回，其以前做過的動作因此全部還原。

	C. Transaction的並行處理(一般為了效率, 不會按順序處理, 都採並行)  --- 線上講義ch12
		a. 任意交錯執行可能會有以下問題:
			I. 更新遺失的問題（The Lost Update Problem）
			II. 污染讀取的問題（The Dirty Read Problem）
			III. 無法重複讀取的問題（The Non-repeatable Read Problem）
			IV. 幽靈資料的問題（The Phantom Problem）

	D. Checkpoint機制:
	reference:
	https://www.newton.com.tw/wiki/CheckPoint
	http://debussy.im.nuu.edu.tw/sjchen/Database/Final/Ch09.pdf

	E. 隔離等級

	F. 二階段鎖
	reference:
	https://zhuanlan.zhihu.com/p/133823461
	https://www.twblogs.net/a/5d407451bd9eee51fbf99a58
	https://www.itread01.com/articles/1476768602.html

	G. deadlock(死鎖)
		a. 發生機制:
			I. Mutual Exclusion:
				🤔. 一個resource一次只能被一個process用

			II. Hold and wait:
				🤔. process至少取到一個resource，然後等其他process握住的resource

			III. No preemption:
				🤔. 釋放資源時，是process自願的，沒有被中斷

			IIII. Circular wait:
				🤔. 每個process都在等另一個process握住的resource釋放(例如：P1等P2、P2等P3、P3等P1)，這也代表single process不會有deadlock

		b. 範例:
			I. Alice要使用資源x和y, Bob也要使用資源x和y
			II. Alice鎖定x, Bob鎖定y
			III. Alice等待y解除鎖定
			IIII. Bob等待x解除鎖定

		c. 解決辦法(發生在作業系統):
			reference: 
			https://ithelp.ithome.com.tw/articles/10206472

			I. Prevention(預防)
				🤔. 要在程式的設計上徹底考慮deadlock發生的情況, 設計起來很麻煩

			II. Aoidance(避免)
				🤔. Resource-Allocation Graph(RAG) 算法, 
					😄. 使用時機: 如果resource type 只有一個instance
				🤔. Banker's Algorithm 算法
					😄. 使用時機: 如果resource type有多個instance

			III. Detection(偵測): 容許deadlock發生, 但能偵測且恢復
				🤔. single instance:
					😄. 使用wait-for graph算法(跟RAG很像)
				🤔. several instance:
					🤔. 使用detection algorithm	

			IIII. Ignore(忽略)
				🤔. 當deadlock發生時, 系統就直接interrupt process
				🤔. 很多作業系統這樣做, 因為上面3種辦法都會消耗資源, 直接interrupt反而划算
		
		d. 解決辦法(發生在資料庫, 其解法與作業系統十分類似):
			I. deadlock detection與回滾:
				🤔. dbms定期檢查deadlock發生, 並採取回滾其中一個trasaction以解除deadlock

			II. deadlock overtime(超時):
				🤔. 設置一個超時時間, 超過該時間, trasaction仍處於deadlock, 則自動終止其中一個trasaction
			
			III. 優化database和查詢語句:
				🤔. 通過合理的database結構設計, 優化index, 減少trasaction持有lock的時間
	
			IIII. 使用鎖定機制: 
				🤔. 使用dbms提供的鎖定機制來手動管理trasaction之間的併發訪問, 避免deadlock

			IIIII. 調整trasaction隔離級別:
				🤔. 將trasaction級別從serializable調整為repeatable read或read committed

			IIIIII. 編寫應用程序時注意trasaction順序
		


|#############################################################################################################|
6. nosql


|#############################################################################################################|
7. 資料倉儲
	A. 定義:
		a. 通常集合了多個資料庫的資料, 他的目的是把多方面(或多個系統)的資料統一集中儲存和處理, 而通常資料庫的資料只針對一個系統

	B. 與資料庫的區別:
	reference:
	https://stackoverflow.com/questions/3419353/what-is-the-difference-between-a-database-and-a-data-warehouse
	注意腰果的答案
	https://www.zhihu.com/question/24110442
		a. 資料庫:  --> 有效地檢索、更新和管理資料。
			I. 資料庫使用OLTP(online Transaction processing) 
			II. 資料庫通常用於再線的業務處理
			III. 通常要求正規化, 節省儲存空間
			IV. 不適合用來分析(效率不好)

		b. 資料倉儲 --> 用於集成和分析大量資料的系統，通常來自於不同來源的資料
			I. 資料倉儲使用(OLAP, online analytical processing)
 			II. 資料倉儲用於數據分析, 數據挖掘, 機器學習, 特徵分析
			III. 不正規化, 為了節省分析需求所花費的時間, 增加效率
			IV. 適合拿來分析

	C. 常見操作
		a. 上卷（Roll Up）/聚合：选定某些维度，根据这些维度来聚合事实，如果用SQL来表达就是select dim_a, aggs_func(fact_b) from fact_table group by dim_a.e.g. 风控场景：点赞场景，决策REJECT，UV多少
		b. 下钻（Drill Down）：上卷和下钻是相反的操作。它是选定某些维度，将这些维度拆解出小的维度（如年拆解为月，省份拆解为城市），之后聚合事实。e.g. 风控场景：点赞场景，命中规则A，决策REJECT，UV多少
		c. 切片（Slicing、Dicing）：选定某些维度，并根据特定值过滤这些维度的值，将原来的大Cube切成小cube。如dim_a in ('CN', 'USA')e.g. 风控场景：点赞场景，命中规则A、规则B，规则C，决策REJECT，UV是多少
		d. 旋转（Pivot/Rotate）：维度位置的互换
		



|#############################################################################################################|
8. 資料庫考題
選擇題(不分章節):
https://www.itest.org.tw/PDF/9912exam/IDD-9912.pdf
https://www.takming.edu.tw/course/%E4%B8%89%E5%B9%B4%E7%B4%9A%E8%B3%87%E6%96%99%E5%BA%AB.pdf

選擇題(分章節):


申論題(分章節):
https://www.mis.nsysu.edu.tw/db-book/pro_ch3.html
參考book:
https://www.mis.nsysu.edu.tw/db-book/PDF/Ch1.pdf
http://debussy.im.nuu.edu.tw/sjchen/Database/Final/Ch03.pdf

申論題2:
http://debussy.im.nuu.edu.tw/sjchen/Database/Final/Ch06.pdf



8. 
