|#############################################################################################################|
1. 資料庫的基本類型:
	A. 階層式
		a. 樹結構
		b. 例如: file system
	B. 網狀式
		b. 網狀結構, node之間可以互聯
	C. 關聯式
		c. sql類型, 也是最廣泛使用的
	D. 物件導向式
		d. 使用程式語言中class的概念來儲存數據

|#############################################################################################################|
2. 資料庫的架構
	A. 單機
	B. 終端
	C. 主從(client-server)
		a. 就是一般常見的架構
	D. 分散式
		a. 由多台數據庫server組合而成, 
		b. 使用者在存取資料時, 資料可以來自於不同的伺服器中
		c. 效率較好, server負擔較小, 但也較難建立


|#############################################################################################################|
3. ER Model(ER digram)
reference:
關於圖形代號的完整說明如下參考:
https://www.conceptdraw.com/examples/erd-double-line
弱實體的連接, "完全參與", "部分參與":
https://faculty.stust.edu.tw/~jehuang/oracle/ch2/2-1.htm
一個討論:
https://stackoverflow.com/questions/19781294/whats-the-difference-in-notation-for-total-participation-and-recursive-relation

	A. Chen's notation (以下整理比較容易忘記或混淆的一些概念)
		a. 弱實體(weak entity)
			I. 所謂弱實體就是必須依賴於其他實體而存在, 例如在學生資料庫中"學生家長"實體依賴於"學生"實體, A學生若從資料庫清除了, A學生的家長自然也就不存在
			II. 使用雙矩形(外面加邊框)表示
		b. 弱關係: 實體和弱實體之間關係用雙菱形(外面加邊框)表示(一班的只用普通菱形)

		c. "推導屬性"即是可從其他屬性推導出來, 例如星座可從出生日期推導.  推導屬性用"虛線橢圓"表示

		d. "多值屬性" 即是擁有很多值得屬性, 例如專長屬性, 可以有好幾種專長, 多值屬性用"雙橢圓(加邊框)"表示

		e. "total participation", "partial participation"
		reference:
		https://faculty.stust.edu.tw/~jehuang/oracle/ch2/2-1.htm
			I. 我們知道, A, B兩個entities 之間有一個"關係"R, 若A裡面的instance必定完全參加R則 稱A完全參與R(total participation), 用"double line"表示, 若instance不需要完全參加R則表示部分參加(partial participation), 用single line表示, B也是一樣的
			II. 弱實體(weak entity)C必定依附於一個實體D, 他們之間的關係R, C必定完全參加R(但是D不見得完全參加R), 所以weak entity在ER圖中, 至少有一條double line, 且此double line指向的關係必定是依附於他的"母親"entity

	B. Crow's foot

	C. ERD設計的三個原則, 就是...
		a. 找出並條列出所有entity
		b. 找出並條列出所有實體對應的所有attributes
		c. 找出所有entity之間的關聯, 並條列出來
		d. 按照條列劃出ERD

	D. 實際設計範例題目:
		https://medium.com/pierceshih/%E7%AD%86%E8%A8%98-%E5%AF%A6%E9%AB%94%E9%97%9C%E8%81%AF%E5%9C%96-87c3ecbc5ff0
		https://www.mis.nsysu.edu.tw/db-book/pro_ch3.html

	E. EER model(enhance ER model)
	reference:
	http://uml.org.cn/sjjm/Chapter10-4.pdf


|#############################################################################################################|
4. 資料庫設計
	A. 正規化(normalization)
	reference:
	https://stackoverflow.com/questions/723998/what-are-database-normal-forms-and-can-you-give-examples/724032#724032
		a. 第一正規化: 把可以拆分的欄位拆出, 且不能有重複的資料(一樣)的資料, 也就是需要有primary key
		b. 第二正規化: 部分相依於primary keys的欄位必須獨立出去
		c. 第三正規化: 欄位本身不相依於primary keys, 但她所相依的欄位卻完全相依於primary keys, 這樣的欄位也要獨立出去
		d. BCNF
		reference:
		以下的解釋有一個精采的範例
		https://www.youtube.com/watch?v=VWnKUKH4tLg
		另一個解釋, 但不是很好(範例有問題!)
		https://stackoverflow.com/questions/8437957/difference-between-3nf-and-bcnf-in-simple-terms-must-be-able-to-explain-to-an-8

			I. "candidate keys(候選鍵)"----可以唯一決定record的欄位集合(可能有很多種),不接受冗餘欄位, candidate keys 為super keys的子集合
			II. "super keys(超鍵)"----可以唯一決定record的欄位集合(可能有很多種), 接受冗餘欄位.
			III. "functional dependency(函數相依)"---- Y依賴X, 記做 X -> Y
			IIII. "closure(閉包)"----一樣是集合論的概念, 假設一個集合S裡的元素, 經過F運算後仍然在該集合中, 則我們稱"這集合S在F運算下閉合(closed)", 當一個集合 S 在某個運算下不閉合的時候，我們通常可以找到包含 S 的最小的閉合集合。這個最小閉合集合被稱為 S 的（關於這個運算的）閉包(closure)!!!!

		e. 在已知依賴關係的情況下candidate keys的找法(記住, candidate keys是super keys的最小子集合, 當然可能有很多個, 我們把所有的super keys找出, 自然能發現candidate keys)
			🤔. question1:
				R = {A, B, C, D, E}, function dependencies are: A->B, ED->A, BC->E, 則candidates keys為{A, C, D}, {B, C, D}, {C, D, E}
	
				Solution:
					其實很簡單, 一步一步做就很清楚了
					首先找出所有沒有考慮相依性的superkeys(其實就只有R本身而已)
					{A, B, C, D, E} 
					在找出只考慮一個相依性的superkeys
					{A, C, D, E} (在這裡我們替除了B, 因為A->B, B依賴A)
					{B, C, D, E} (在這裡我們替除了A, 因為ED->A, A依賴ED)
					{A, B, C, D} (在這裡我們替除了E, 因為BC->E, E依賴BC)
					接著按照上面的結果, 再多考慮一個相依性的superkeys
					{C, D, E} (在這裡我們從{A, C, D, E}出發, 考慮了ED->A)
					{B, C, D} (在這裡我們從{B, C, D, E}出發, 考慮了BC->E)
					{A, C, D} (在這裡我們從{A, B, C, D}出發, 考慮了A->B)
					接下來無法再依照相依性剔除任何元素了...所以superkeys為以下:
					{A, B, C, D, E}, {A, C, D, E}, {B, C, D, E}, {A, C, C, D}, {C, D, E}, {B, C, D}, {A, C, D}
					candidate keys為最小的子集合, 所以如下:
					{C, D, E}, {B, C, D}, {A, C, D}

			🤔. question2:
				R = {A, B, C, D}, function dependencies are: D->B, AB->D, AB->C, C->A, 則candidates keys為{C, D}, {A, B}, {B, C}, {A, D}

				solution: 
					一樣, 與上一題一模一樣的方式,找出所有superkeys
					{A, B, C, D}
					{A, C, D} (根據D->B) 
					{A, B, C} (根據AB->D)
					{A, B, D} (根據AB->C)
					{B, C, D} (根據C->A)
					{C, D} (根據D->B, C->A)
					{A, B} (根據AB->D, AB->C)
					{B, C} (根據AB->D, C->A)
					{A, D} (根據AB->C, D->B)
					{A, B} (根據AB->C, AB->D)
					{C, D} (根據C->A, D->B)
					剔除重複的狀況後, 得到candidate keys為
					{C, D}, {A, B}, {B, C}, {A, D}	

	C. 索引(index):
		a. 基本解釋: 為何可以增加搜索數據的速度, 其實不難理解, 資料存入資料庫若是沒有任何資料結構, 那搜索將採用線性搜索, 也就是時間複雜度是O(n), 如果做了B-Tree的索引結構, 那搜索速率自然提升到O(log(n)) 

		b. 缺點:  雖然索引(index)會使搜索效率提升, 但是insert, 或update的速率是會下降的, 因為他需要先找到, 才能插入或update, 但是沒做索引的話, 直接插入就好, 不用理會index的結構到底如何


|#############################################################################################################|
5. transaction(交易)
沒時間了...除了講義以外, 記得看以下reference:
https://zhuanlan.zhihu.com/p/133823461
	A. ACID(Atomicity, Consistency, Isolation, Durability)
	reference:
	https://lance.coderbridge.io/2021/04/24/short-what-is-acid/

		a. Atomicity
			I. Transaction為最小單元, 不可再分割, Transaction內的運算只能一起成功或一起失敗
		b. Consistency
			I. Transaction的運算必須與現實世界的規則一致
		c. Isolation
			I. Transaction之間互相獨立, 彼此不會互相影響
		d. Durability
			I. Transaction commit 後, 其運算結果應在具有持久性

	B. Transaction的執行:
		a. 概念上, 一個交易是由數個以下五種基本運算動作所組成：
			I. begin(T)：表示一個交易T開始執行。
			II. read(X, x)：表示從硬碟讀取資料項X到主記憶體變數x。
			III. write(x, X)：表示將主記憶體變數x寫至硬碟資料項X。
			IV. commit(T)：表示一個交易T成功的結束。
			V abort(T)：表示一個交易T被駁回，其以前做過的動作因此全部還原。

	C. Transaction的並行處理(一般為了效率, 不會按順序處理, 都採並行)  --- 線上講義ch12
		a. 任意交錯執行可能會有以下問題:
			I. 更新遺失的問題（The Lost Update Problem）
			II. 污染讀取的問題（The Dirty Read Problem）
			III. 無法重複讀取的問題（The Non-repeatable Read Problem）
			IV. 幽靈資料的問題（The Phantom Problem）

	D. Checkpoint機制:
	reference:
	https://www.newton.com.tw/wiki/CheckPoint
	http://debussy.im.nuu.edu.tw/sjchen/Database/Final/Ch09.pdf

	E. 二階段鎖
	reference:
	https://zhuanlan.zhihu.com/p/133823461
	https://www.twblogs.net/a/5d407451bd9eee51fbf99a58
	https://www.itread01.com/articles/1476768602.html

	F. deadlock(死鎖)
		a. 發生機制:
			I. Mutual Exclusion:
				🤔. 一個resource一次只能被一個process用

			II. Hold and wait:
				🤔. process至少取到一個resource，然後等其他process握住的resource

			III. No preemption:
				🤔. 釋放資源時，是process自願的，沒有被中斷

			IIII. Circular wait:
				🤔. 每個process都在等另一個process握住的resource釋放(例如：P1等P2、P2等P3、P3等P1)，這也代表single process不會有deadlock

		b. 範例:
			I. Alice要使用資源x和y, Bob也要使用資源x和y
			II. Alice鎖定x, Bob鎖定y
			III. Alice等待y解除鎖定
			IIII. Bob等待x解除鎖定

		c. 解決辦法(發生在作業系統):
			reference: 
			https://ithelp.ithome.com.tw/articles/10206472

			I. Prevention(預防)
				🤔. 要在程式的設計上徹底考慮deadlock發生的情況, 設計起來很麻煩

			II. Aoidance(避免)
				🤔. Resource-Allocation Graph(RAG) 算法, 
					😄. 使用時機: 如果resource type 只有一個instance
				🤔. Banker's Algorithm 算法
					😄. 使用時機: 如果resource type有多個instance

			III. Detection(偵測): 容許deadlock發生, 但能偵測且恢復
				🤔. single instance:
					😄. 使用wait-for graph算法(跟RAG很像)
				🤔. several instance:
					🤔. 使用detection algorithm	

			IIII. Ignore(忽略)
				🤔. 當deadlock發生時, 系統就直接interrupt process
				🤔. 很多作業系統這樣做, 因為上面3種辦法都會消耗資源, 直接interrupt反而划算
		
		d. 解決辦法(發生在資料庫, 其解法與作業系統十分類似):
			I. deadlock detection與回滾:
				🤔. dbms定期檢查deadlock發生, 並採取回滾其中一個trasaction以解除deadlock

			II. deadlock overtime(超時):
				🤔. 設置一個超時時間, 超過該時間, trasaction仍處於deadlock, 則自動終止其中一個trasaction
			
			III. 優化database和查詢語句:
				🤔. 通過合理的database結構設計, 優化index, 減少trasaction持有lock的時間
	
			IIII. 使用鎖定機制: 
				🤔. 使用dbms提供的鎖定機制來手動管理trasaction之間的併發訪問, 避免deadlock

			IIIII. 調整trasaction隔離級別:
				🤔. 將trasaction級別從serializable調整為repeatable read或read committed

			IIIIII. 編寫應用程序時注意trasaction順序
		


|#############################################################################################################|
6. nosql





|#############################################################################################################|
7. 資料庫考題
選擇題(不分章節):
https://www.itest.org.tw/PDF/9912exam/IDD-9912.pdf
https://www.takming.edu.tw/course/%E4%B8%89%E5%B9%B4%E7%B4%9A%E8%B3%87%E6%96%99%E5%BA%AB.pdf

選擇題(分章節):


申論題(分章節):
https://www.mis.nsysu.edu.tw/db-book/pro_ch3.html
參考book:
https://www.mis.nsysu.edu.tw/db-book/PDF/Ch1.pdf
http://debussy.im.nuu.edu.tw/sjchen/Database/Final/Ch03.pdf

申論題2:
http://debussy.im.nuu.edu.tw/sjchen/Database/Final/Ch06.pdf



8. 
